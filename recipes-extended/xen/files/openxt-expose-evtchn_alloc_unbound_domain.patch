[Xen-devel] [PATCH (V9) 1/2] xen: events, exposes evtchn_alloc_unbound_domain

Exposes evtchn_alloc_unbound_domain to the rest of
Xen so we can create allocated unbound evtchn within Xen.

Signed-off-by: Ross Philipson <ross.philipson@citrix.com>
---
 xen/common/event_channel.c |   45 +++++++++++++++++++++++++++++++-------------
 xen/include/xen/event.h    |    3 +++
 2 files changed, 35 insertions(+), 13 deletions(-)

diff --git a/xen/common/event_channel.c b/xen/common/event_channel.c
index 64c976b..d416f97 100644
--- a/xen/common/event_channel.c
+++ b/xen/common/event_channel.c
@@ -160,35 +160,54 @@ static int get_free_port(struct domain *d)
 
 static long evtchn_alloc_unbound(evtchn_alloc_unbound_t *alloc)
 {
-    struct evtchn *chn;
     struct domain *d;
-    int            port;
-    domid_t        dom = alloc->dom;
     long           rc;
 
-    d = rcu_lock_domain_by_any_id(dom);
+    d = rcu_lock_domain_by_any_id(alloc->dom);
     if ( d == NULL )
         return -ESRCH;
 
-    spin_lock(&d->event_lock);
+    rc = evtchn_alloc_unbound_domain(d, &alloc->port, alloc->remote_dom, 1);
+    if ( rc )
+        ERROR_EXIT_DOM((int)rc, d);
 
-    if ( (port = get_free_port(d)) < 0 )
-        ERROR_EXIT_DOM(port, d);
-    chn = evtchn_from_port(d, port);
+ out:
+    rcu_unlock_domain(d);
 
-    rc = xsm_evtchn_unbound(XSM_TARGET, d, chn, alloc->remote_dom);
-    if ( rc )
+    return rc;
+}
+
+int evtchn_alloc_unbound_domain(struct domain *d, evtchn_port_t *port,
+                                domid_t remote_domid, bool_t call_xsm)
+{
+    struct evtchn *chn;
+    int           rc;
+    int           free_port;
+
+    spin_lock(&d->event_lock);
+
+    rc = free_port = get_free_port(d);
+    if ( free_port < 0 )
         goto out;
 
+    chn = evtchn_from_port(d, free_port);
+    if ( call_xsm )
+    {
+        rc = xsm_evtchn_unbound(XSM_TARGET, d, chn, remote_domid);
+        if ( rc )
+            goto out;
+    }
+
     chn->state = ECS_UNBOUND;
-    if ( (chn->u.unbound.remote_domid = alloc->remote_dom) == DOMID_SELF )
+    if ( (chn->u.unbound.remote_domid = remote_domid) == DOMID_SELF )
         chn->u.unbound.remote_domid = current->domain->domain_id;
 
-    alloc->port = port;
+    *port = free_port;
+    /* Everything is fine, returns 0 */
+    rc = 0;
 
  out:
     spin_unlock(&d->event_lock);
-    rcu_unlock_domain(d);
 
     return rc;
 }
diff --git a/xen/include/xen/event.h b/xen/include/xen/event.h
index 4ac39ad..5edca53 100644
--- a/xen/include/xen/event.h
+++ b/xen/include/xen/event.h
@@ -69,6 +69,9 @@ int guest_enabled_event(struct vcpu *v, uint32_t virq);
 /* Notify remote end of a Xen-attached event channel.*/
 void notify_via_xen_event_channel(struct domain *ld, int lport);
 
+int evtchn_alloc_unbound_domain(struct domain *d, evtchn_port_t *port,
+                                domid_t remote_domid, bool_t call_xsm);
+
 /* Internal event channel object accessors */
 #define bucket_from_port(d,p) \
     ((d)->evtchn[(p)/EVTCHNS_PER_BUCKET])
-- 
1.7.10.4
